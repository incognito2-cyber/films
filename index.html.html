<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>TextCrypt Pro</title>
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#007bff" />
  <link rel="icon" href="icon-192.png" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker
        .register('service-worker.js')
        .then(() => console.log('‚úÖ Service Worker –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω'))
        .catch((err) => console.error('‚ùå –û—à–∏–±–∫–∞ Service Worker:', err));
    }
  </script>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 20px;
      max-width: 700px;
      margin: auto;
      background: var(--bg);
      color: var(--text);
      transition: background 0.3s, color 0.3s;
    }
    :root {
      --bg: #f0f0f0;
      --text: #222;
      --btn-bg: #007bff;
      --btn-hover: #0056b3;
      --input-bg: #fff;
      --input-border: #ccc;
    }
    [data-theme='dark'] {
      --bg: #121212;
      --text: #eee;
      --btn-bg: #1a73e8;
      --btn-hover: #185abc;
      --input-bg: #222;
      --input-border: #555;
    }
    textarea,
    input[type='text'] {
      width: 100%;
      padding: 10px;
      margin: 8px 0;
      border-radius: 8px;
      border: 1px solid var(--input-border);
      font-size: 16px;
      background: var(--input-bg);
      color: var(--text);
      box-sizing: border-box;
    }
    button {
      width: 100%;
      padding: 12px;
      background: var(--btn-bg);
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 18px;
      cursor: pointer;
      margin-bottom: 10px;
      transition: background 0.3s;
    }
    button:hover {
      background: var(--btn-hover);
    }
    #themeToggle {
      width: auto;
      padding: 8px 20px;
      margin-bottom: 20px;
    }
    #fileInput {
      display: none;
    }
  </style>
</head>
<body>
  <h2>üîê TextCrypt Pro ‚Äî AES-GCM + PBKDF2</h2>

  <button id="themeToggle">üåô –¢—ë–º–Ω–∞—è —Ç–µ–º–∞</button>

  <textarea id="input" placeholder="–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–ª–∏ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç..."></textarea>
  <input type="text" id="password" placeholder="–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å" autocomplete="new-password" />

  <button onclick="encrypt()">üîí –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
  <button onclick="decrypt()">üîì –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å</button>
  <button onclick="copyOutput()">üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
  <button onclick="exportText()">üíæ –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç</button>
  <button onclick="document.getElementById('fileInput').click()">üìÇ –ò–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—Å—Ç</button>

  <input type="file" id="fileInput" accept=".txt" />

  <textarea id="output" placeholder="–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ—è–≤–∏—Ç—Å—è –∑–¥–µ—Å—å..." readonly></textarea>

  <script>
    // –¢–µ–º–∞
    const themeToggle = document.getElementById('themeToggle');
    const userPrefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;

    function setTheme(dark) {
      if (dark) {
        document.documentElement.setAttribute('data-theme', 'dark');
        themeToggle.textContent = '‚òÄÔ∏è –°–≤–µ—Ç–ª–∞—è —Ç–µ–º–∞';
        localStorage.setItem('theme', 'dark');
      } else {
        document.documentElement.removeAttribute('data-theme');
        themeToggle.textContent = 'üåô –¢—ë–º–Ω–∞—è —Ç–µ–º–∞';
        localStorage.setItem('theme', 'light');
      }
    }
    themeToggle.onclick = () => {
      const dark = document.documentElement.getAttribute('data-theme') !== 'dark';
      setTheme(dark);
    };
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–µ–º—ã
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme) {
      setTheme(savedTheme === 'dark');
    } else {
      setTheme(userPrefersDark);
    }

    // –£—Ç–∏–ª–∏—Ç—ã
    function showNotification(message) {
      if ('Notification' in window && Notification.permission === 'granted') {
        new Notification(message);
      } else {
        alert(message);
      }
    }

    // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–∞ PBKDF2 –∏–∑ –ø–∞—Ä–æ–ª—è + —Å–æ–ª—å
    async function deriveKey(password, salt) {
      const enc = new TextEncoder();
      const keyMaterial = await window.crypto.subtle.importKey(
        'raw',
        enc.encode(password),
        { name: 'PBKDF2' },
        false,
        ['deriveKey']
      );
      return window.crypto.subtle.deriveKey(
        {
          name: 'PBKDF2',
          salt: salt,
          iterations: 100000,
          hash: 'SHA-256',
        },
        keyMaterial,
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt']
      );
    }

    // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è ArrayBuffer –≤ Base64
    function ab2b64(buffer) {
      const bytes = new Uint8Array(buffer);
      let binary = '';
      for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return btoa(binary);
    }

    // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è Base64 –≤ ArrayBuffer
    function b642ab(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes.buffer;
    }

    async function encrypt() {
      const text = document.getElementById('input').value;
      const password = document.getElementById('password').value;
      if (!text || !password) {
        alert('–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏ –ø–∞—Ä–æ–ª—å');
        return;
      }
      try {
        const enc = new TextEncoder();
        const salt = window.crypto.getRandomValues(new Uint8Array(16));
        const key = await deriveKey(password, salt);
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const encoded = enc.encode(text);
        const cipherBuffer = await window.crypto.subtle.encrypt(
          { name: 'AES-GCM', iv: iv },
          key,
          encoded
        );
        // –°–æ–±–∏—Ä–∞–µ–º: salt + iv + ciphertext –≤ base64
        const combined = new Uint8Array(salt.byteLength + iv.byteLength + cipherBuffer.byteLength);
        combined.set(salt, 0);
        combined.set(iv, salt.byteLength);
        combined.set(new Uint8Array(cipherBuffer), salt.byteLength + iv.byteLength);
        const encrypted = ab2b64(combined.buffer);
        document.getElementById('output').value = encrypted;
        showNotification('üîê –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!');
      } catch (e) {
        alert('–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è: ' + e.message);
      }
    }

    async function decrypt() {
      const encrypted = document.getElementById('input').value;
      const password = document.getElementById('password').value;
      if (!encrypted || !password) {
        alert('–í–≤–µ–¥–∏—Ç–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç –∏ –ø–∞—Ä–æ–ª—å');
        return;
      }
      try {
        const data = b642ab(encrypted);
        const salt = data.slice(0, 16);
        const iv = data.slice(16, 28);
        const ciphertext = data.slice(28);
        const key = await deriveKey(password, new Uint8Array(salt));
        const decryptedBuffer = await window.crypto.subtle.decrypt(
          { name: 'AES-GCM', iv: new Uint8Array(iv) },
          key,
          ciphertext
        );
        const dec = new TextDecoder();
        const decrypted = dec.decode(decryptedBuffer);
        document.getElementById('output').value = decrypted;
        showNotification('üîì –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!');
      } catch (e) {
        alert('‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–∞—Ä–æ–ª—å –∏ —Ç–µ–∫—Å—Ç.');
      }
    }

    function copyOutput() {
      const output = document.getElementById('output');
      output.select();
      output.setSelectionRange(0, 99999); // –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö
      document.execCommand('copy');
      alert('üìã –°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞!');
    }

    function exportText() {
      const text = document.getElementById('output').value;
      if (!text) {
        alert('–ù–µ—á–µ–≥–æ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å!');
        return;
      }
      const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'textcrypt_output.txt';
      a.click();
      URL.revokeObjectURL(a.href);
    }

    function importText(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (e) {
        document.getElementById('input').value = e.target.result;
      };
      reader.readAsText(file);
    }
    document.getElementById('fileInput').addEventListener('change', importText);
  </script>
</body>
</html>
